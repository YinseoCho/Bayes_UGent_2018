A brief introduction to the tidyverse
========================================================
author: Antonio Schettino
date: Ghent University (Belgium)
autosize: true
transition: none
width: 1600
height: 1000
css: css-file.css

<!-- For syntax highlighting -->
<link rel="stylesheet" href="github.css">

```{r setup_Rpres, include = FALSE, echo = FALSE, warning = FALSE, message = FALSE}
options(htmltools.dir.version = FALSE)
```

Outline
========================================================
incremental: true
type: lineheight



Description of the dataset
========================================================
incremental: true
type: lineheight



participants viewed a
total of nine mock adverts over three sessions. In these adverts there were three products (a brand
of beer, a brand of wine, and a brand of water). These could be presented alongside positive,
negative or neutral imagery. Over the three sessions and nine adverts, each type of product was
paired with each type of imagery (read the previous chapter if you need more detail). After each
advert participants rated the drinks on a scale ranging from –100 (dislike very much) through 0
(neutral) to 100 (like very much). The design, thus far, has two independent variables: the type of
drink (beer, wine or water) and the type of imagery used (positive, negative or neutral). I also
took note of each person’s gender. It occurred to me that men and women might respond
differently to the products (because, in keeping with stereotypes, men might mostly drink lager
whereas women might drink wine).


There is evidence from advertising research that attitudes towards stimuli can be changed using
positive imagery (e.g., Stuart, Shimp, & Engle, 1987). As part of an initiative to stop binge drinking in
teenagers, the government funded some scientists to look at whether negative imagery could be used
to make teenagers’ attitudes towards alcohol more negative. The scientists designed a study to address
this issue by comparing the effects of negative imagery against positive and neutral imagery for
different types of drinks. Table 13.4 illustrates the experimental design and contains the data for this
example (each row represents a single participant).
Participants viewed a total of nine mock adverts over three sessions. In one session, they saw three
adverts: (1) a brand of beer (Brain Death) presented with a negative image (a dead body with the
slogan ‘drinking Brain Death makes your liver explode’); (2) a brand of wine (Dangleberry) presented
in the context of a positive image (a sexy naked man or woman – depending on the participant’s
preference – and the slogan ‘drinking Dangleberry wine makes you irresistible’); and (3) a brand of
water (Puritan) presented alongside a neutral image (a person watching television accompanied by the
slogan ‘drinking Puritan water makes you behave completely normally’). In a second session (a week
later), the participants saw the same three brands, but this time Brain Death was accompanied by the
positive imagery, Dangleberry by the neutral image and Puritan by the negative. In a third session, the
participants saw Brain Death accompanied by the neutral image, Dangleberry by the negative image
and Puritan by the positive. After each advert participants were asked to rate the drinks on a scale
ranging from – 100 (dislike very much) through 0 (neutral) to 100 (like very much). The order of
adverts was randomized, as was the order in which people participated in the three sessions. This
design is quite complex. There are two independent variables: the type of drink (beer, wine or water)
and the type of imagery used (positive, negative or neutral). These two variables completely cross
over, producing nine experimental conditions









Setup
========================================================
incremental: true
type: lineheight

```{r setup}
# if you want a clean environment:
# dev.off() # clear plots (if no plots are present, comment it out or it will throw an error)
# cat("\014") # clear console
# rm(list=ls()) # clear environment

# install packages
install.packages("tidyverse")

# load packages
library(tidyverse)

# in which directory are we now?
getwd()

# set directory
setwd(paste0(getwd(), "/day1_intro_R_tidyverse/"))

# did it work?
getwd()
```

Load dataset
========================================================
incremental: true
type: lineheight

```{r load_data}
# load data
attitude <- 
    read.table(
        "MixedAttitude.dat", # file name
        header = TRUE)       # data has headers

# see data in console
attitude

# check variables in data frame
str(attitude)

# see data in RStudio
View(attitude)
```

Clean & save dataset
========================================================
incremental: true
type: lineheight

```{r clean_data}
# there was a technical problem while recording the data of participant #99,
# i.e., the rating scale was out of the -100/100 range

# filter out participant #99
# (more specifically, keep all participants that are NOT participant #99)
attitude.noOutlier <- 
    attitude %>%
    filter(ssj!=99)

# THE PIPE OPERATOR
# read it as "and then"
# in the example above, load data.attitude "and then" filter out participant #99 

# for our exercises, we will only need a subset of variables in this dataset
# select and rename variables of interest
attitude.noOutlier.selected <- 
    attitude.noOutlier %>%
    select(participant = ssj,
           gender,
           beer_negative = beerneg,
           beer_neutral = beerneut,
           water_negative = waterneg,
           water_neutral = waterneu)

# let's look at the variable 'gender'
attitude.noOutlier.selected$gender
unique(attitude.noOutlier.selected$gender)
class(attitude.noOutlier.selected$gender)

# the 'gender' variable contains 1s and 2s, which is not very clear
# we will transform 'gender' as a factor with two levels, male and female 
# Andy Field does not specify the coding, so we will assume that 1 is female and 2 is male
attitude.noOutlier.selected.recoded <- 
    attitude.noOutlier.selected %>%
    mutate(sex = recode(                           # create a new variable 'sex'
                    factor(gender),                # convert variable 'gender' as factor
                    "1" = "female", "2" = "male")) # assign labels to factor levels

# now we have two variables with identical information...
# let's get rid of 'gender'
attitude.noOutlier.selected.recoded <- 
    attitude.noOutlier.selected.recoded %>%
    select(-gender)

# many functions in the packages we are going to use in this course need data in long format
# wide format: one row per participant
# long format: one row per observation

# convert from wide to long format
attitude.noOutlier.selected.recoded.long <-
    attitude.noOutlier.selected.recoded %>% 
    gather(key = "condition",               # name of new variable with all condition levels
           value = "ratings",               # name of new variable with all values
           beer_negative:water_neutral)     # variables to be collapsed

# this experiment had two independent variables: 
# drink (beer or water) and imagery (neutral or negative)
# in our analysis we will need to know the separate contribution
# of these two independent variables and their interaction
# so, we need to separate 'condition' into 2 variables
attitude.noOutlier.selected.recoded.long.sep <-
    attitude.noOutlier.selected.recoded.long %>%
    separate(condition, c("drink", "imagery")) %>% # the separation occurs here
    # transform to factors
    mutate(participant = factor(participant),
           drink = factor(drink),
           imagery = factor(imagery))

# .dat file format is not what the cool kids use
# save data as .csv
write_csv(attitude.noOutlier.selected.recoded.long.sep,
          paste0(getwd(), "/data_attitude.csv"))    # full path & file name

# # read from .csv
# attitude.noOutlier.selected.recoded.long.sep <- read_csv(paste0(getwd(), "/data_attitude.csv"))

# all these modifications can be done in one go
attitude.noOutlier.selected.recoded.long.sep <-
    attitude %>%
    filter(ssj!=99) %>%
    select(participant = ssj,
           gender,
           beer_negative = beerneg,
           beer_neutral = beerneut,
           water_negative = waterneg,
           water_neutral = waterneu) %>%
    mutate(sex = recode(
                    factor(gender),
                    "1" = "female", "2" = "male")) %>%
    select(-gender) %>%
    gather(key = "condition",
           value = "ratings",
           beer_negative:water_neutral) %>%
    separate(condition, c("drink", "imagery")) %>%
    mutate(participant = factor(participant),
           drink = factor(drink),
           imagery = factor(imagery)) %>%
    write_csv(.,                                       # the point indicates the current data frame
              paste0(getwd(), "/data_attitude.csv"))
```

Summarize dataset
========================================================
incremental: true
type: lineheight

```{r summarize_data}
# summarize data
summary.attitude.noOutlier.selected.recoded.long.sep <-
    attitude.noOutlier.selected.recoded.long.sep %>%
    group_by(drink, imagery) %>%                        # group according to conditions
    summarize(n = n(),                                  # number of observations
              mean = mean(ratings),                     # mean
              sd = sd(ratings),                         # standard deviation
              sem = sd/sqrt(n),                         # standard error of the mean
              min = min(ratings),                       # range (min)
              max = max(ratings),                       # range (max)
              ci.95 = 1.96 * sem)                       # 95% confidence interval

# # group according to sex and conditions
# summary.attitude.noOutlier.selected.recoded.long.sep.sex <-
#     attitude.noOutlier.selected.recoded.long.sep %>%
#     group_by(sex, drink, imagery) %>%
#     summarize(n = n(),
#               mean = mean(ratings),
#               sd = sd(ratings),               
#               sem = sd/sqrt(n),
#               min = min(ratings),
#               max = max(ratings),
#               ci.95 = 1.96 * sem)
```


Plots
========================================================
incremental: true
type: lineheight


```{r plot_data}
# the most basic bar plot
# uses aggregated data
summary.attitude.noOutlier.selected.recoded.long.sep %>%
    ggplot(.,                                            # data
           aes(x = drink,                                # 'product' on x-axis
               y = mean,                                 # mean ratings on y-axis
               fill = imagery)) +                        # separate colors for each level of 'imagery'
    geom_bar(stat = "identity")                          # use the values in the data frame (no transformations)

# it's a stacked bar graph! we don't want that!
summary.attitude.noOutlier.selected.recoded.long.sep %>%
    ggplot(.,
           aes(x = drink,
               y = mean,
               fill = imagery)) +
    geom_bar(stat = "identity",
             position = position_dodge())                 # bars are next to each other

# add outlines
summary.attitude.noOutlier.selected.recoded.long.sep %>%
    ggplot(.,
           aes(x = drink,
               y = mean,
               fill = imagery)) +
    geom_bar(stat = "identity",
             position = position_dodge(),
             color = "black")                             # black outlines

# something is missing... ah, error bars!
summary.attitude.noOutlier.selected.recoded.long.sep %>%
    ggplot(.,
           aes(x = drink,
               y = mean,
               fill = imagery)) +
    geom_bar(stat = "identity",
             position = position_dodge(),
             color = "black") +
    geom_errorbar(aes(ymin = mean - ci.95,                # mean ratings ± 95% confidence interval
                      ymax = mean + ci.95),
                  width = .2,                             # width of the error bars
                  position = position_dodge(.9))          # position (centered on the bar)

# these colors are hideous... let's use a more decent color palette
install.packages("viridis") # 'viridis' uses colors that are easier to distinguish for people with colorblindness
library(viridis)

summary.attitude.noOutlier.selected.recoded.long.sep %>%
    ggplot(.,
           aes(x = drink,
               y = mean,
               fill = imagery)) +
    geom_bar(stat = "identity",
             position = position_dodge(),
             color = "black") +
    geom_errorbar(aes(ymin = mean - ci.95,
                      ymax = mean + ci.95),
                  width = .2,
                  position = position_dodge(.9)) +
    scale_fill_viridis(option = "viridis",                # see ?scale_color_viridis for other color palettes
                       discrete = TRUE)                   # map colors to discrete values

# other cosmetic variations
summary.attitude.noOutlier.selected.recoded.long.sep %>%
    ggplot(.,
           aes(x = drink,
               y = mean,
               fill = imagery)) +
    geom_bar(stat = "identity",
             position = position_dodge(),
             color = "black") +
    geom_errorbar(aes(ymin = mean - ci.95,
                      ymax = mean + ci.95),
                  width = .2,
                  position = position_dodge(.9)) +
    scale_fill_viridis(option = "viridis",
                       discrete = TRUE) +
    scale_y_continuous("",                                    # y-axis: no title
                       limits = c(-15, 15),                   # y-axis: min/max values
                       breaks = seq(-15, 15, 5)) +            # y-axis: tick marks
    ggtitle("mean ratings") +                                 # plot title
    theme_classic(base_size = 18) +                           # text size
    theme(plot.title = element_text(size = 24,                # title: text size
                                    hjust = .5),              # title: centered
          legend.position = c(.9, .9))                        # legend position (upper right corner)
    
# no matter how pretty you make a bar graph, it still conceals information about the distribution of data points
# the following graph shows:
# * points representing the raw data
# * smoothed densities
# * box and whisker plot:
#   - vertical bars: medians
#   - boxes: upper and lower quartile
#   - whiskers: minimum and maximum values
attitude.noOutlier.selected.recoded.long.sep %>%
    unite("condition", c(drink, imagery)) %>%                  # paste 'drink' and 'imagery' columns into 'condition'
    # plot
    ggplot(., 
           aes(x = condition, 
               y = ratings)) +
    # box and whisker plot
    geom_boxplot(alpha = 1,                                    # boxes: transparency
                 size = .5,                                    # boxes: line thickness
                 outlier.alpha = 0) +                          # outliers: transparency
    stat_boxplot(geom = 'errorbar',                            # whiskers
                 size = .5,                                    # whiskers: line thickness
                 width = .25) +                                # whiskers: width
    # violin plot
    geom_violin(aes(fill = condition),                         # density: color fill
                color = "transparent",                         # outline: color
                alpha = .25) +                                 # density: transparency
    # jittered data points
    geom_jitter(size = 3,                                      # point: size
                alpha = .3,                                    # point: transparency
                position = position_jitter(width = .1)) +      # point: jitter
    scale_fill_viridis(option = "viridis",                     # color palette for all fills
                       discrete = TRUE) + 
    scale_color_viridis(option = "viridis",                    # color palette for all outlines
                        discrete = TRUE) + 
    scale_x_discrete(limits =                                  # x-axis: set variable order
                         c("water_neutral", "water_negative", 
                           "beer_neutral", "beer_negative")) + 
    scale_y_continuous(name = "",                              # y-axis: title
                       limits=c(-25, 35),                      # y-axis: min/max values
                       breaks=seq(-25, 35, 5)) +               # y-axis: tick marks
    geom_hline(yintercept = seq(-25, 35, 5),                   # reference lines
               linetype = "dotted",                            # reference lines: type
               colour = "#999999",                             # reference lines: color
               size = .8,                                      # reference lines: thickness
               alpha = .5) +                                   # reference lines: transparency
    ggtitle("mean ratings") +                                  # plot title
    theme_classic(base_size = 18) +                            # custom theme (resize text)
    theme(legend.position="none",                              # no legend
          plot.title = element_text(size = 24, hjust = .5))    # resize and center title

# if you don't want to waste time doing it yourself, I recommend the 'yarrr' package
# the following graph shows:
# * points representing the raw data
# * smoothed densities
# * vertical bars showing central tendencies
# * rectangles representing inference intervals (e.g., 95% confidence intervals)
install.packages("yarrr") 
library(yarrr)

pirateplot(formula = ratings ~ imagery + drink,                 # dependent ~ independent variables
           data = attitude.noOutlier.selected.recoded.long.sep, # data frame
           main = "mean ratings",                               # plot title
           ylim = c(-25, 35),                                   # y-axis: axis limits
           ylab = "",                                           # y-axis: no label
           inf.method = "ci",                                   # type of inference: 95% confidence interval
           inf.within = participant,                            # ID variable
           # theme settings
           pal = "espresso",                                    # color palette: see piratepal("all")
           point.o = .5,                                        # data points: opacity (0-1)
           point.cex = 1.3,                                     # data points: size
           bean.b.o = .6,                                       # bean border: opacity (0-1)
           bean.f.o = .6,                                       # bean filling: opacity (0-1)
           cap.beans = TRUE,                                    # bean densities are capped at the data limits
           bty = "n",                                           # no box around the plot
           gl.col = "gray",                                     # background line color (major and minor lines)
           gl.lwd = 1,                                          # background line width
           gl.lty = 2)                                          # background line type (dashed)
```

repeated measures ANOVA
========================================================
incremental: true
type: lineheight

```{r rANOVA}


install.packages("afex") # this package also installs a ton of other useful packages... including 'brms' ;)

library(afex)
library(multcomp)

# repeated measures ANOVA
rmANOVA.attitude <- aov_ez("participant",                                # variable with subject identifier
                           "ratings",                                    # dependent variable
                           attitude.noOutlier.selected.recoded.long.sep, # data frame
                           within = c("drink", "imagery"),               # within-subject variable
                           type = 3)                                     # type-III sums of squares (default in SPSS)

rmANOVA.attitude

# post-hoc tests
afex_options(emmeans_model = "multivariate") # use appropriate degrees of freedom (NOT Satterthwaite approximated)

posthoc.attitude <-
    summary(
        as.glht(                                            # better p-value adjustment for multiple testing
            pairs(                                          # compare differences between levels of indepedent variable
                emmeans(rmANOVA.attitude, ~ imagery:drink), # estimated marginal means
                test = adjusted("free")                     # "free": generalization of Bonferroni-Holm correction,
            )                                               # taking into account correlations among model parameters
        )
    )

posthoc.attitude

# bootstrapped effect sizes
install.packages("bootES")

library(bootES)

# prepare data frame
attitude.bootES <-
    attitude.noOutlier.selected.recoded.long.sep %>%
    unite("condition", c(drink, imagery)) %>%                                  # create 'condition' variable
    spread(condition, ratings) %>%                                             # convert from long to wide format
    # compute mean differences
    mutate(beer_negativeVSbeer_neutral = beer_negative - beer_neutral,
           beer_negativeVSwater_negative = beer_negative - water_negative,
           beer_negativeVSwater_neutral = beer_negative - water_neutral,
           beer_neutralVSwater_negative = beer_neutral - water_negative,
           beer_neutralVSwater_neutral = beer_neutral - water_neutral,
           water_negativeVSwater_neutral = water_negative - water_neutral) %>%
    # delete unused variables (avoid conflict with MASS::lm.ridge)
    dplyr::select(-c(beer_negative:water_neutral)) %>% 
    # re-convert to long format
    gather(key = "diff.conds",
           value = "ratings",
           beer_negativeVSbeer_neutral:water_negativeVSwater_neutral)

# apply functions iteratively
attitude.HedgesG <- 
    attitude.bootES %>%
    split(.$diff.conds) %>%               # split conditions in separate lists
    # apply bootES function to all lists
    map(~bootES(.,                        # data
                data.col = "ratings",     # dependent variable
                R = 5000,                 # number of samples
                effect.type = "hedges.g", # type of effect size
                ci.type = "bca",          # bootstrap method
                ci.conf = .95))           # confidence level

str(attitude.HedgesG)

# initialize summary table
summary.attitude.bootES <- data.frame(magrittr::extract2(posthoc.attitude, 1)$object,
                                      "Hedges.G" = NA,
                                      "CI.95.low" = NA,
                                      "CI.95.high" = NA,
                                      "bias" = NA,
                                      "std.error" = NA)

for(i in 1:length(unique(attitude.bootES$diff.conds))) { # loop through conditions
    summary.attitude.bootES[i, 7:11] <- summary(magrittr::extract2(attitude.HedgesG, i))
}

summary.attitude.bootES <- format(summary.attitude.bootES, digits = 3)

summary.attitude.bootES
```


